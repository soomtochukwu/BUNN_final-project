{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "contracts/BUNN_Governor_Proxy.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"./restrictions.sol\";\nimport \"./utility_token-interface.sol\";\nimport \"./governor_storage.sol\";\n\ncontract BUNN_GOVERNOR is governor_storage, Restrictions {\n    /* **************************\n    Section B: Events\n    \n    ***************************/\n    event decision_implemented(string title, uint topic_id, bool implemented);\n    event vote_cast(\n        address indexed participant,\n        uint topic_acted_on,\n        bool position\n    );\n\n    event proposal_made(address indexed proposer, string topic);\n    event new_member(address indexed new_member);\n    event new_Admin(address indexed newAdmin);\n    event remove_Admin(address indexed demotedAdmin);\n\n    /* ************************* */\n    constructor(\n        address utility_token_address_,\n        address upgraded_logic_contract\n    ) {\n        utility_token_address = utility_token_address_;\n        admin[msg.sender].is_admin = true;\n        logic_contract = upgraded_logic_contract;\n    }\n\n    /*************************\n    Section C: Functions\n    *************************/\n\n    function register(string memory name_ /* , uint256 d_tokens */) public {\n        (bool success, ) = logic_contract.delegatecall(\n            abi.encodeWithSignature(\"register(string)\", name_)\n        );\n        require(success, \"FAILED TO REGISTER\");\n    }\n\n    // A qualified user initiates a TOPIC/PROPOSAL\n    function initiate_topic(\n        string memory title_,\n        string memory details_,\n        address implementation_contract_address_,\n        string memory signature_\n    ) public {\n        bytes memory data = abi.encodeWithSignature(\n            \"initiate_topic(string,string,address,string)\",\n            title_,\n            details_,\n            implementation_contract_address_,\n            signature_\n        );\n        (bool success, ) = logic_contract.delegatecall(data);\n\n        require(success, \"FAILED TO INITIATE TOPIC\");\n    }\n\n    // A qualified user casts their vote(s)\n    function cast_vote(uint256 topic_id, bool position_) public {\n        Topic memory topic = Topics[topic_id];\n        IUTILITY_TOKEN BUNN = IUTILITY_TOKEN(utility_token_address);\n        uint256 end_time = voting_duration + topic.start_time;\n\n        /*sanity checks*/\n        // check if the Topic is cancelled\n        require(!topic.cancelled, \"INVALID VOTE. TOPIC IS CANCELLED\");\n        // check if sender is a registered user\n        require(Members[msg.sender].belongs, \"NOT A MEMBER\");\n        // check if the voting period has expired\n        require(end_time > block.timestamp, \"VOTING PERIOD HAS ELAPSED\");\n        // ensure that the voter has enough tokens\n        require(\n            BUNN.balanceOf(msg.sender) > 0,\n            \"YOU MUST POSSES TOKENs TO BE AN ELIGIBLE VOTER\"\n        );\n        uint256 voting_power_ = BUNN.balanceOf(msg.sender);\n\n        // map users vote against the topic they voted for\n        // it is supposed to track users who participated in the decision\n\n        require(\n            !ballots[msg.sender][topic_id].voted,\n            \"MEMBERS CAN ONLY CAST A VOTE PER TOPIC\"\n        );\n        ballots[msg.sender][topic_id] = ballot({\n            Topic_ID: topic_id,\n            position: position_,\n            voted: true,\n            voting_power: voting_power_\n        });\n\n        // count votes based on voting power\n        if (ballots[msg.sender][topic_id].position) {\n            votes[topic_id].for_votes =\n                votes[topic_id].for_votes +\n                voting_power_;\n        } else {\n            votes[topic_id].against_votes =\n                votes[topic_id].against_votes +\n                voting_power_;\n        }\n\n        emit vote_cast(msg.sender, topic.id, position_);\n    }\n\n    // execute/implement a decision or topic is it passed the voting process\n    function implement_decision(\n        uint256 topic_id,\n        bool _override\n    ) public payable onlyAdmin {\n        (bool success, ) = logic_contract.delegatecall(\n            abi.encodeWithSignature(\n                \"implement_decision(uint256,bool)\",\n                topic_id,\n                _override\n            )\n        );\n        require(success, \"FAILED TO IMPLEMENT DECISION\");\n    }\n\n    function cancel_Topic(uint256 topic_id) public onlyAdmin {\n        Topics[topic_id].cancelled = true;\n    }\n\n    /*************************\n    Section D: Maintenance/Upgrade\n    *************************/\n    function UPGRADE(address upgraded_logic_contract) public onlyAdmin {\n        logic_contract = upgraded_logic_contract;\n    }\n\n    function UPGRADE_UTA(address upgraded_utility_token) public onlyAdmin {\n        utility_token_address = upgraded_utility_token;\n    }\n\n    modifier onlyAdmin() {\n        require(admin[msg.sender].is_admin, \"ACCESS DENIED!\");\n        _;\n    }\n\n    function addAdmin(address newAdmin) public onlyAdmin {\n        if (admin[newAdmin].adders >= admins.length) {\n            admin[newAdmin].is_admin = true;\n            admins.push(newAdmin);\n            admin[newAdmin].adders = admin[newAdmin].adders + 1;\n        } else {\n            admin[newAdmin].adders = admin[newAdmin].adders + 1;\n        }\n\n        emit new_Admin(newAdmin);\n    }\n\n    function removeAdmin(address demotedAdmin) public onlyAdmin {\n        // require(admin[demotedAdmin].removers > (admins.length/2), \"\");\n        if (admin[demotedAdmin].removers >= admins.length - 1) {\n            admin[demotedAdmin].is_admin = false;\n            admin[demotedAdmin].removers = admin[demotedAdmin].removers + 1;\n        } else {\n            admin[demotedAdmin].removers = admin[demotedAdmin].removers + 1;\n        }\n\n        emit remove_Admin(demotedAdmin);\n    }\n}\n"
    },
    "contracts/BUNN_Logic.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"./restrictions.sol\";\nimport \"./utility_token-interface.sol\";\nimport \"./governor_storage.sol\";\n\ncontract BUNN_GOVERNOR_LOGIC is governor_storage, Restrictions {\n    /* **************************\n    Section B: Events\n    \n    **************************/\n    event decision_implemented(string title, uint topic_id, bool implemented);\n    event vote_cast(\n        address indexed participant,\n        uint topic_acted_on,\n        bool position\n    );\n    event proposal_made(address indexed proposer, string topic);\n    event new_member(address indexed new_member);\n    event new_Admin(address indexed newAdmin);\n    event remove_Admin(address indexed demotedAdmin);\n\n    /* ************************* */\n    constructor() {}\n\n    /*************************\n    Section C: Functions\n    *************************/\n\n    function register(string memory name_ /* , uint256 d_tokens */) public {\n        Members[msg.sender] = Member({\n            name: name_,\n            belongs: true /* ,\n            delegated_tokens: d_tokens */\n        });\n        emit new_member(msg.sender);\n    }\n\n    // A qualified user initiates a TOPIC/PROPOSAL\n    function initiate_topic(\n        string memory title_,\n        string memory details_,\n        address implementation_contract_address_,\n        string memory signature_\n    ) public {\n        /* sanity checks */\n        require(Members[msg.sender].belongs, \"NOT A MEMBER\");\n\n        Topic memory new_topic = Topic({\n            id: counter,\n            title: title_,\n            initiator: msg.sender,\n            details: details_,\n            implementation_contract_address: implementation_contract_address_,\n            signature: signature_,\n            start_time: block.timestamp,\n            executed: false,\n            cancelled: false\n        });\n\n        // require(Topics[new_topic.id], \"FAILED TO INITIATE TOPIC\");\n\n        Topics[new_topic.id] = new_topic;\n\n        counter = counter + 1;\n        emit proposal_made(msg.sender, new_topic.title);\n    }\n\n    // A qualified user casts their vote(s)\n    function cast_vote(uint256 topic_id, bool position_) public {\n        // Topic memory topic = Topics[topic_id];\n        // IUTILITY_TOKEN BUNN = IUTILITY_TOKEN(utility_token_address);\n        // /*sanity checks*/\n        // // check if the Topic is cancelled\n        // require(!topic.cancelled, \"INVALID VOTE. TOPIC IS CANCELLED\");\n        // // check if sender is a registered user\n        // require(Members[msg.sender].belongs, \"NOT A MEMBER\");\n        // // check if the voting period has expired\n        // uint256 end_time = voting_duration + topic.start_time;\n        // require(end_time > block.timestamp, \"VOTING PERIOD HAS ELAPSED\");\n        // // ensure that the voter has enough tokens\n        // require(\n        //     BUNN.balanceOf(msg.sender) > 0,\n        //     \"YOU MUST POSSES TOKENs TO BE AN ELIGIBLE VOTER\"\n        // );\n        // // map users vote against the topic they voted for\n        // // it is supposed to track users who participated in the decision\n        // require(!ballots[msg.sender][topic_id].voted, \"MEMBERS CAN ONLY CAST A VOTE PER TOPIC\");\n        // ballots[msg.sender][topic_id] = ballot({\n        //     Topic_ID: topic_id,\n        //     position: position_,\n        //     voted: true\n        // });\n        // if (ballots[msg.sender][topic_id].position) {\n        //     votes[topic_id].for_votes = votes[topic_id].for_votes + 1;\n        // }else {\n        //     votes[topic_id].against_votes = votes[topic_id].against_votes + 1;\n        // }\n        // emit vote_cast(msg.sender, topic.id, position_);\n    }\n\n    // execute/implement a decision or topic is it passed the voting process\n    function implement_decision(\n        uint256 topic_id,\n        bool _override\n    ) public payable onlyAdmin {\n        Topic memory topic_to_implement;\n        address implementation_contract;\n        string memory signature;\n\n        uint256 total_votes = votes[topic_id].for_votes +\n            votes[topic_id].against_votes;\n        uint256 end_time = voting_duration + topic_to_implement.start_time;\n        topic_to_implement = Topics[topic_id];\n        implementation_contract = topic_to_implement\n            .implementation_contract_address;\n        signature = topic_to_implement.signature;\n\n        /* sanity checks */\n        // check if voting is still in progress\n        if (_override) {\n            //\n        } else {\n            require(\n                end_time > block.timestamp,\n                \"CANNOT IMPLEMENT BECAUSE VOTING IS STILL IN PROGRESS\"\n            );\n        }\n        //check the quorum\n        require(\n            quorum(votes[topic_id].for_votes, total_votes),\n            \"THRESHOLD NOT EXCEEDED\"\n        );\n        // check that the topic has not been cancelled\n        require(!topic_to_implement.cancelled, \"THIS TOPIC IS CANCELLED\");\n        // topic can only be implemented once\n        require(\n            !topic_to_implement.executed,\n            \"TOPIC CAN ONLY BE IMPLEMENTED ONCE\"\n        );\n        // implement topic\n        (bool success, bytes memory returned_data) = implementation_contract\n            .call{value: msg.value}(abi.encodeWithSignature(signature));\n        // confirm successful implementation\n        require(success, \"FAILED TO IMPLEMENT\");\n        mark_as_executed(topic_id);\n        // emit respective event\n        emit decision_implemented(topic_to_implement.title, topic_id, success);\n        returned = abi.decode(returned_data, (uint256));\n    }\n\n    function mark_as_executed(uint256 topic_id) private {\n        Topics[topic_id].executed = true;\n    }\n\n    /*************************\n    Section D: Maintenance/Upgrade\n    *************************/\n\n    modifier onlyAdmin() {\n        require(admin[msg.sender].is_admin, \"ACCESS DENIED!\");\n        _;\n    }\n\n    function addAdmin(address newAdmin) public onlyAdmin {\n        if (admin[newAdmin].adders >= admins.length) {\n            admin[newAdmin].is_admin = true;\n            admins.push(newAdmin);\n            admin[newAdmin].adders = admin[newAdmin].adders + 1;\n        } else {\n            admin[newAdmin].adders = admin[newAdmin].adders + 1;\n        }\n\n        emit new_Admin(newAdmin);\n    }\n\n    function removeAdmin(address demotedAdmin) public onlyAdmin {\n        // require(admin[demotedAdmin].removers > (admins.length/2), \"\");\n        if (admin[demotedAdmin].removers >= admins.length - 1) {\n            admin[demotedAdmin].is_admin = false;\n            admin[demotedAdmin].removers = admin[demotedAdmin].removers + 1;\n        } else {\n            admin[demotedAdmin].removers = admin[demotedAdmin].removers + 1;\n        }\n\n        emit remove_Admin(demotedAdmin);\n    }\n}\n"
    },
    "contracts/governance_token.sol": {
      "content": "// Sources flattened with hardhat v2.17.3 https://hardhat.org\n\n// SPDX-License-Identifier: MIT AND SEE\n//\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n// File @openzeppelin/contracts/utils/Context.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v4.9.3\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(\n        address account\n    ) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(\n        address spender,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(\n            fromBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                \"ERC20: insufficient allowance\"\n            );\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n// File contracts/ico-token.sol\n\n// Original license: SPDX_License_Identifier: SEE\npragma solidity ^0.8.19;\n\n// contract BUNN_ICO_TOKEN\ncontract BUNN_UTILITY_TOKEN is ERC20 {\n    uint256 private MAX_SUPPLY;\n    address public owner;\n\n    constructor() ERC20(\"BUNN_UTILITY_TOKEN\", \"BUNN\") {\n        owner = msg.sender;\n        MAX_SUPPLY = 10_000_000_000 * (10 ** decimals());\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Unauthorized Entity\");\n\n        _;\n    }\n\n    //\n    function mint(address account, uint256 amount) public onlyOwner {\n        require(totalSupply() + amount <= MAX_SUPPLY, \"MAX SUPPLY EXCEEDED\");\n        super._mint(account, amount);\n    }\n\n    function buy_tokens() public payable {\n        require(msg.value > 0, \"ETH MUST BE MORE THAN 0\");\n        require(msg.value <= address(msg.sender).balance, \"NOT ENOUGH ETH\");\n        super._mint(msg.sender, (msg.value * 250)); //1 ETH = 250 BUNN\n    }\n\n    function withdraw_funds(address holder, uint256 amount) public onlyOwner {\n        require(address(this).balance > amount, \"INSUFFICIENT FUNDS\");\n        payable(holder).transfer(amount * 1e18);\n    }\n}\n"
    },
    "contracts/governor_storage.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ncontract governor_storage {\n    /**************************\n    Section 0: External resources \n\n    *************************/\n    address public utility_token_address;\n    uint256 public returned;\n    address public logic_contract;\n\n    /**************************\n    Section A: State Variables \n    **************************/\n\n    /*\n    Section A1: defines how members are represented.\n\n    ***MORE DELEGATIONS ON THIS LATER***\n    A member is represented as `Member`.\n    `Members` maps their address to `Member`.\n\n    Members are recorded when they vote, `cast_vote`. \n    */\n    struct admin_ {\n        bool is_admin;\n        uint256 removers;\n        uint256 adders;\n    }\n    mapping(address => admin_) public admin;\n\n    address[] internal admins;\n\n    struct Member {\n        string name; // if necessary\n        bool belongs;\n        /* uint delegated_tokens;*/ // if necessary\n        // other attributes\n    }\n    mapping(address => Member) public Members;\n\n    /* \n    Section A2: defines the voting structure.\n\n    it features a \"ballot box\" represented as a mapping called `votes`.\n    `votes` maps last votes to `ballot`. the last vote is the sum of all votes.\n    `ballot` maps voters' address to their \"ballot paper\".\n\n    Members can cast their vote(s) by calling the `cast_vote` function.\n    */\n    struct ballot {\n        uint256 Topic_ID;\n        bool position;\n        bool voted;\n        uint256 voting_power;\n    }\n    mapping(address => mapping(uint => ballot)) public ballots;\n\n    struct vote {\n        uint256 for_votes;\n        uint256 against_votes;\n    }\n    mapping(uint => vote) public votes;\n\n    /*\n    Section A3a: defines how \"Topics\" of \"Proposals\" is represented.\n\n    `Topic` defines species the required attributes (self-explanatory) of a topic.\n    `Topics` is supposed to track \"Topics\" according to their respective ID(uint).\n\n    Qualified members initiate their \"Topic\" by calling the `initiate_topic` function.\n     */\n    struct Topic {\n        uint256 id;\n        string title;\n        address initiator;\n        string details;\n        address implementation_contract_address;\n        string signature;\n        uint256 start_time;\n        bool executed;\n        bool cancelled;\n    }\n    mapping(uint256 => Topic) public Topics;\n\n    uint256 public counter = 1;\n}\n"
    },
    "contracts/Implementation-test.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ncontract IMPLEMENTATION_CONTRACT {\n    uint256 public state = 0;\n    uint256 public val;\n\n    constructor() {}\n\n    //\n    //functions signature ==> \"function alterState(uint)\"\n    function alterState() public payable returns (uint) {\n        val += msg.value;\n        val /= 1e18;\n        return val;\n    }\n\n    function balance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
    },
    "contracts/restrictions.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/* \n    specifies time-locks and thresholds\n    */\ncontract Restrictions {\n    using Math for uint256;\n\n    uint256 public voting_duration = 432000; // 5days\n    uint256 public implementation_delay = 86400; // 1 day\n\n    // uint256 private quorum = 50%;\n    constructor() {}\n\n    /* \n    here, `target` means the quantity whose threshold is being validated.\n    `comparison` is the represents the quantity `target` is being validated with.\n    it returns a boolean if the quorum is high enough.\n\n    the quorum I have chosen is 60%.\n    */\n    function quorum(\n        uint256 target,\n        uint256 comparison\n    ) public pure returns (bool) {\n        uint256 comp = comparison.mulDiv(60, 100);\n        return target >= comp ? true : false;\n    }\n}\n"
    },
    "contracts/utility_token-interface.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IUTILITY_TOKEN {\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}